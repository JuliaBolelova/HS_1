const defaults = {
    delay: 300,
    closeDelay: 10,
    initDelay: 1000,
    loaderElement: '#js-page-loader',
    classActive: 'is-active',
};
export default class Loader {
    constructor(cfg = {}) {
        this.loaderPromises = [];
        this.suppressOnInit = false;
        this.timeout = null;
        this.closingTimeout = null;
        this.loaderShows = false;
        this.promisesForShownLoader = [];
        this.loaderShownResolver = undefined;
        this.currentLoadingPromise = Promise.resolve([]);
        this.setCurrentLoadingPromise();
        const config = Object.assign(Object.assign({}, defaults), cfg);
        const { loaderElement, initDelay } = config;
        this.config = config;
        this.el = loaderElement instanceof HTMLElement
            ? loaderElement : document.querySelector(loaderElement);
        this.suppressOnInit = true;
        this.initSuppressTimeout = setTimeout(() => {
            this.suppressOnInit = false;
            this.initSuppressTimeout = null;
        }, initDelay);
    }
    setCurrentLoadingPromise() {
        this.currentLoadingPromise = new Promise((resolve) => {
            this.loaderShownResolver = resolve;
        });
    }
    // eslint-disable-next-line sonarjs/cognitive-complexity
    loader(promise, options) {
        var _a;
        const { el, suppressOnInit, loaderPromises, config, initSuppressTimeout, promisesForShownLoader, closingTimeout, } = this;
        const { classActive, delay, closeDelay } = config;
        const skipDelays = (_a = options === null || options === void 0 ? void 0 : options.skipDelays) !== null && _a !== void 0 ? _a : false;
        if ((!suppressOnInit || skipDelays) && el) {
            if (suppressOnInit && skipDelays) {
                clearTimeout(initSuppressTimeout);
                this.suppressOnInit = false;
                this.initSuppressTimeout = null;
            }
            const isFirstLoader = loaderPromises.length === 0;
            loaderPromises.push(promise);
            // eslint-disable-next-line unicorn/consistent-destructuring
            if (this.loaderShows) {
                promisesForShownLoader.push(promise);
            }
            const showLoader = () => {
                el.classList.add(classActive);
                this.loaderShows = true;
                promisesForShownLoader.push(...loaderPromises);
            };
            const hideLoader = () => {
                el.classList.remove(classActive);
                this.loaderShows = false;
                /* istanbul ignore else */
                if (this.loaderShownResolver) { // eslint-disable-line unicorn/consistent-destructuring
                    this.loaderShownResolver(promisesForShownLoader.splice(0, promisesForShownLoader.length));
                }
                this.setCurrentLoadingPromise();
            };
            if (isFirstLoader) { // Only the first loader needs to initialize the show functionality
                if (!closingTimeout) {
                    if (!skipDelays) {
                        // Show loader after a delay. For operation that are finished fast enough no loader is shown.
                        this.timeout = setTimeout(() => {
                            showLoader();
                            this.timeout = null;
                        }, delay);
                    }
                    else {
                        showLoader();
                    }
                }
                else {
                    // Another operation finished shortly before. To avoid flickering the loader closes later.
                    // But here we don't need to close it because another operation starts.
                    clearTimeout(closingTimeout);
                    this.closingTimeout = null;
                }
            }
            const finished = () => {
                const { timeout } = this;
                if (timeout && loaderPromises.length === 1) {
                    // We close the last operation before the loader was shown. There is no need anymore to show it.
                    clearTimeout(timeout);
                    this.timeout = null;
                }
                loaderPromises.splice(loaderPromises.indexOf(promise), 1);
                if (loaderPromises.length === 0) {
                    // The last operation has finished. Show loader a bit longer so there is no flickering when an operation
                    // starts shortly after.
                    this.closingTimeout = setTimeout(() => {
                        hideLoader();
                        this.closingTimeout = null;
                    }, closeDelay);
                }
            };
            promise.then(finished, finished); // eslint-disable-line promise/prefer-await-to-then
        }
        return promise;
    }
    wrapFunction(fnc, options) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias, unicorn/no-this-assignment
        const loaderCtx = this;
        return function (...args) {
            return loaderCtx.loader(fnc.apply(this, args), options);
        };
    }
    decorator(options) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias, unicorn/no-this-assignment
        const loaderCtx = this;
        return function (target, propertyKey, descriptor) {
            const oldValue = descriptor.value;
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            descriptor.value = function (...params) {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                return loaderCtx.loader(oldValue.apply(this, params), options);
            };
        };
    }
}
